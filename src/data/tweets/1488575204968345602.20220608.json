{"lang":"en","favorite_count":1083,"self_thread":{"id_str":"1488575204968345602"},"created_at":"2022-02-01T18:09:19.000Z","display_text_range":[0,279],"entities":{"hashtags":[],"urls":[],"user_mentions":[],"symbols":[],"media":[{"display_url":"pic.twitter.com/bhxPXk1CLf","expanded_url":"https://twitter.com/lexi_lambda/status/1488575204968345602/photo/1","indices":[280,303],"url":"https://t.co/bhxPXk1CLf"}]},"id_str":"1488575204968345602","text":"I really wish people were more familiar with the original context of the “premature optimization” quote, because it is not nearly as general a statement as a lot of people seem to want it to be. Here is the actual text from Structured Programming with go to Statements, by Knuth. https://t.co/bhxPXk1CLf","user":{"id_str":"855835988","name":"Alexis King","profile_image_url_https":"https://pbs.twimg.com/profile_images/1428920518867099651/CceVtgLi_normal.jpg","screen_name":"lexi_lambda","verified":false},"photos":[{"accessibilityLabel":"The improvement in speed from Example 2 to Example 2a is only about 12%, and many people would pronounce that insignificant. The conventional wisdom shared by many of today’s software engineers calls for ignoring efficiency in the small; but I believe this is simply an overreaction to the abuses they see being practiced by pennywise-and-pound-foolish programmers, who can’t debug or maintain their “optimized” programs. In established engineering disciplines a 12% improvement, easily obtained, is never considered marginal; and I believe the same viewpoint should prevail in software engineering. Of course I wouldn’t bother making such optimizations on a one-shot job, but when it’s a question of preparing quality programs, I don’t want to restrict myself to tools that deny me such efficiencies.","backgroundColor":{"red":204,"green":214,"blue":221},"cropCandidates":[{"x":0,"y":503,"w":1106,"h":619},{"x":0,"y":99,"w":1106,"h":1106},{"x":0,"y":0,"w":1057,"h":1205},{"x":0,"y":0,"w":603,"h":1205},{"x":0,"y":0,"w":1106,"h":1205}],"expandedUrl":"https://twitter.com/lexi_lambda/status/1488575204968345602/photo/1","url":"https://pbs.twimg.com/media/FKh6OATX0AAwaJx.png","width":1106,"height":1205},{"accessibilityLabel":"There is no doubt that the grail of efficiency leads to abuse. Programmers waste enormous amounts of time worrying about the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We *should* forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.\n\nYet we should not pass up our opportunities in that critical 3%. A good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only *after* that code has been identified. It is often a mistake to make a priori judgments about what parts of a program are really critical, since the universal experience of programmers who have been using measurement tools has been that their intuitive guesses fail.","backgroundColor":{"red":204,"green":214,"blue":221},"cropCandidates":[{"x":0,"y":0,"w":1106,"h":619},{"x":0,"y":0,"w":1106,"h":1106},{"x":0,"y":0,"w":1106,"h":1261},{"x":0,"y":0,"w":866,"h":1732},{"x":0,"y":0,"w":1106,"h":1732}],"expandedUrl":"https://twitter.com/lexi_lambda/status/1488575204968345602/photo/1","url":"https://pbs.twimg.com/media/FKh66uCXIAMJenO.png","width":1106,"height":1732}],"conversation_count":29,"news_action_type":"conversation"}